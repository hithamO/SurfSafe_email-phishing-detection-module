### 1. File & Folder Structure Tree

```
.
├── cache/                  # Directory for storing cached data
│   └── vt_cache.db         # SQLite database for VirusTotal results cache
├── config/                 # Directory for configuration files
│   └── config.py           # Main configuration loading and validation logic
├── src/                    # Directory containing the core source code
│   ├── ai_integration.py   # Handles interaction with the AI model (prompt building, API calls)
│   ├── database_manager.py # Manages the SQLite cache database (CRUD operations, pruning)
│   ├── email_parser.py     # Parses input email files (.eml, .msg) and performs initial validation
│   ├── report_generator.py # Formats and prints the final analysis report to the console
│   └── security_analyzer.py# Contains core analysis logic (headers, body, attachments, VT, OCR, helpers)
└── main.py                 # Main script execution entry point, orchestrates the analysis flow
```

### 2. Function/Method Structure Overview

---

**File:** `config/config.py`

*   **Class:** `Config`
    *   **Purpose:** Manages application configuration, loading defaults, applying overrides (environment variables, dictionary), and validating settings.
    *   **`__init__(self, overrides: Dict = None)`**
        *   **Purpose:** Initializes the configuration object.
        *   **Inputs:** `overrides` (Optional dictionary of settings).
        *   **Outputs:** None.
        *   **Dependencies:** `os` (for `getenv`), `logging`, `sys`, `pytesseract` (optional, for setting path).
        *   **Internal Calls:** `self.validate()`, `self._configure_logging()`.
        *   **Behavior:** Copies defaults, applies overrides, checks environment variables for API keys, calls validation, configures logging, optionally sets Tesseract path. Exits on critical validation failure.
        *   **Data:** Reads environment variables (`OPENROUTER_API_KEY`, `VIRUSTOTAL_API_KEY`), default dictionary `DEFAULTS`.
        *   **Validation:** Checks critical parameter types and values via `self.validate()`.
        *   **Logs:** Info on loading/validation, Warnings for missing keys or invalid settings, Critical on validation failure.
    *   **`_configure_logging(self)`**
        *   **Purpose:** Sets up the root logger based on configuration settings.
        *   **Inputs:** None (uses `self.config`).
        *   **Outputs:** None.
        *   **Dependencies:** `logging`.
        *   **Internal Calls:** None.
        *   **Behavior:** Reads `LOG_LEVEL` and `LOG_FORMAT` from `self.config`, sets the basicConfig for the root logger. Defaults to INFO if level is invalid.
        *   **Data:** Reads `LOG_LEVEL`, `LOG_FORMAT` from `self.config`.
        *   **Logs:** Info on configured logging level, Warning if level was invalid.
    *   **`validate(self)`**
        *   **Purpose:** Checks critical configuration parameters for validity.
        *   **Inputs:** None (uses `self.config`).
        *   **Outputs:** None (raises `ValueError` on failure).
        *   **Dependencies:** `logging`.
        *   **Internal Calls:** None.
        *   **Behavior:** Performs type and value checks on `SUPPORTED_FILES`, `MAX_FILE_SIZE`, timeouts, delays, cache duration, database path, log level, OCR settings, AI URL.
        *   **Data:** Reads various keys from `self.config`.
        *   **Validation:** Core validation logic for configuration.
        *   **Logs:** Warnings for non-critical issues (e.g., invalid LOG_LEVEL, non-HTTP AI URL).
    *   **`get(self, key: str, default: Any = None)`**
        *   **Purpose:** Safely retrieves a configuration value.
        *   **Inputs:** `key` (setting name), `default` (value if key not found).
        *   **Outputs:** The configuration value or the default.
        *   **Dependencies:** None.
        *   **Internal Calls:** None.
        *   **Behavior:** Uses dictionary `.get()` on `self.config`.
        *   **Data:** Reads from `self.config`.

*   **Global Variable:** `CONFIG`
    *   **Purpose:** A globally accessible instance of the `Config` class, holding the application's configuration.

---

**File:** `src/email_parser.py`

*   **Class:** `EmailAnalysisError(Exception)`
    *   **Purpose:** Custom exception type for errors specific to email parsing.
    *   **Behavior:** Inherits from base `Exception`.

*   **Function:** `parse_email(file_path: str)`
    *   **Purpose:** Reads, validates, and parses an email file (`.eml` or `.msg`).
    *   **Inputs:** `file_path` (string path to the email file).
    *   **Outputs:** Dictionary containing `message` (EmailMessage object), `raw_content` (string), `filename` (string).
    *   **Dependencies:** `email`, `os`, `logging`, `config.config.CONFIG`, `extract_msg` (optional, runtime import).
    *   **Internal Calls:** None.
    *   **Behavior:**
        1.  Checks file existence and type (`os.path.exists`, `os.path.isfile`).
        2.  Checks file size against `CONFIG.MAX_FILE_SIZE` (`os.path.getsize`).
        3.  Validates file extension against `CONFIG.SUPPORTED_FILES`.
        4.  If `.eml`, reads bytes and parses using `email.message_from_bytes`.
        5.  If `.msg`, attempts to import `extract_msg`, reads using `extract_msg.Message`, extracts body, parses using `email.message_from_string`.
        6.  Decodes raw content to UTF-8 string.
        7.  Raises `EmailAnalysisError` or `ImportError` on failure.
    *   **Data:** Reads email file content from `file_path`. Reads settings from `CONFIG`.
    *   **Validation:** File existence, type, size, extension.
    *   **Logs:** Debug on attempt, Info on success, Error/Exception on failures.

---

**File:** `src/database_manager.py`

*   **Class:** `DatabaseManager`
    *   **Purpose:** Manages the SQLite database for caching VirusTotal results asynchronously.
    *   **`__init__(self, db_path: str, cache_duration_seconds: int)`**
        *   **Purpose:** Initializes the manager with database path and cache duration.
        *   **Inputs:** `db_path`, `cache_duration_seconds`.
        *   **Outputs:** None.
        *   **Dependencies:** `aiosqlite` (optional, runtime check), `logging`, `asyncio`.
        *   **Internal Calls:** None.
        *   **Behavior:** Stores config, creates an `asyncio.Lock`, sets `_db_initialized` flag to `False`. Logs error if `aiosqlite` is missing.
        *   **Data:** Stores `db_path`, `cache_duration_seconds`.
    *   **`_get_connection(self)`** (async)
        *   **Purpose:** Establishes an asynchronous connection to the SQLite database file.
        *   **Inputs:** None.
        *   **Outputs:** `aiosqlite.Connection` object or `None`.
        *   **Dependencies:** `aiosqlite`, `os`, `sqlite3`, `logging`.
        *   **Internal Calls:** None.
        *   **Behavior:** Checks if `aiosqlite` exists. Ensures DB directory exists (`os.makedirs`). Connects using `aiosqlite.connect`, sets row factory. Returns connection or logs error and returns `None`.
        *   **Data:** Uses `self.db_path`.
    *   **`init_db(self)`** (async)
        *   **Purpose:** Creates the cache table and index if they don't exist, using a lock for safety.
        *   **Inputs:** None.
        *   **Outputs:** None.
        *   **Dependencies:** `aiosqlite`, `sqlite3`, `logging`, `asyncio`.
        *   **Internal Calls:** `self._get_connection()`, `self._init_lock.acquire/release` (implicitly via `async with`).
        *   **Behavior:** Checks if already initialized or `aiosqlite` missing. Acquires lock. Gets connection. Executes `CREATE TABLE IF NOT EXISTS` and `CREATE INDEX IF NOT EXISTS`. Commits changes. Sets `_db_initialized` flag. Releases lock. Closes connection. Handles errors.
    *   **`get_cached_result(self, indicator: str, indicator_type: str)`** (async)
        *   **Purpose:** Retrieves a non-expired cached result for a given indicator.
        *   **Inputs:** `indicator`, `indicator_type`.
        *   **Outputs:** Dictionary (parsed JSON result) or `None`.
        *   **Dependencies:** `aiosqlite`, `sqlite3`, `json`, `time`, `logging`.
        *   **Internal Calls:** `self.init_db()`, `self._get_connection()`, `self.delete_cached_result` (on JSON error).
        *   **Behavior:** Ensures DB init. Gets connection. Queries `vt_cache` table for indicator/type. Checks if found row's timestamp is within `self.cache_duration_seconds`. Parses stored JSON string. Handles JSON decode errors by deleting the entry. Returns parsed dict or `None`. Closes connection.
        *   **Data:** Reads from `vt_cache` table. Uses `self.cache_duration_seconds`.
        *   **Validation:** Checks cache entry timestamp. Validates JSON structure implicitly via `json.loads`.
    *   **`store_result(self, indicator: str, indicator_type: str, result: Dict[str, Any])`** (async)
        *   **Purpose:** Stores or updates a result in the cache.
        *   **Inputs:** `indicator`, `indicator_type`, `result` (dictionary).
        *   **Outputs:** None.
        *   **Dependencies:** `aiosqlite`, `sqlite3`, `json`, `time`, `logging`.
        *   **Internal Calls:** `self.init_db()`, `self._get_connection()`.
        *   **Behavior:** Ensures DB init. Gets connection. Serializes `result` dict to JSON string. Gets current timestamp. Executes `INSERT OR REPLACE` into `vt_cache`. Commits. Closes connection. Handles errors.
        *   **Data:** Writes to `vt_cache` table.
    *   **`delete_cached_result(self, indicator: str, indicator_type: str)`** (async)
        *   **Purpose:** Deletes a specific entry from the cache.
        *   **Inputs:** `indicator`, `indicator_type`.
        *   **Outputs:** None.
        *   **Dependencies:** `aiosqlite`, `sqlite3`, `logging`.
        *   **Internal Calls:** `self._get_connection()`.
        *   **Behavior:** Gets connection. Executes `DELETE FROM vt_cache` based on indicator/type. Commits. Closes connection. Handles errors.
        *   **Data:** Deletes from `vt_cache` table.
    *   **`prune_old_cache(self)`** (async)
        *   **Purpose:** Removes all cache entries older than the configured duration.
        *   **Inputs:** None.
        *   **Outputs:** None.
        *   **Dependencies:** `aiosqlite`, `sqlite3`, `time`, `logging`.
        *   **Internal Calls:** `self.init_db()`, `self._get_connection()`.
        *   **Behavior:** Ensures DB init. Gets connection. Calculates cutoff timestamp. Executes `DELETE FROM vt_cache` where timestamp is less than cutoff. Commits. Closes connection. Handles errors.
        *   **Data:** Deletes from `vt_cache` table. Uses `self.cache_duration_seconds`.

---

**File:** `src/security_analyzer.py`

*   **Function:** `generate_hashes(data: bytes)`
    *   **Purpose:** Calculate MD5, SHA1, SHA256 hashes for input bytes.
    *   **Inputs:** `data` (bytes).
    *   **Outputs:** Dictionary {'md5': str, 'sha1': str, 'sha256': str} or error strings.
    *   **Dependencies:** `hashlib`, `logging`.
    *   **Internal Calls:** None.
    *   **Behavior:** Uses `hashlib.md5/sha1/sha256` and `.hexdigest()`. Handles empty input and exceptions.
    *   **Data:** Processes input `data`.
*   **Function:** `decode_email_header(header_value: Optional[Any])`
    *   **Purpose:** Safely decode potentially RFC 2047 encoded email header values.
    *   **Inputs:** `header_value` (any type from email header).
    *   **Outputs:** Decoded string, or original string on error.
    *   **Dependencies:** `email.header.decode_header`, `logging`.
    *   **Internal Calls:** None.
    *   **Behavior:** Uses `decode_header`, iterates through parts, decodes bytes using specified or fallback charset, handles errors gracefully. Cleans final string.
    *   **Data:** Processes `header_value`.
*   **Function:** `extract_domain(url_or_email: str)`
    *   **Purpose:** Extract the base registered domain from a URL or email address.
    *   **Inputs:** `url_or_email` (string).
    *   **Outputs:** Lowercase domain string (e.g., 'example.com') or `None`.
    *   **Dependencies:** `re`, `urllib.parse.urlparse`, `logging`.
    *   **Internal Calls:** None.
    *   **Behavior:** Checks for '@', otherwise uses `urlparse`. Extracts netloc/email domain part. Removes port, 'www.', converts to lowercase. Performs basic validation. Handles exceptions.
    *   **Data:** Processes `url_or_email`.
*   **Function:** `is_suspicious_tld(domain: Optional[str])`
    *   **Purpose:** Check if a domain's TLD is in a predefined list of suspicious TLDs.
    *   **Inputs:** `domain` (string or None).
    *   **Outputs:** Boolean.
    *   **Dependencies:** `logging`. Uses constant `SUSPICIOUS_TLDS`.
    *   **Internal Calls:** None.
    *   **Behavior:** Splits domain by '.', checks the last part against `SUSPICIOUS_TLDS`. Handles errors.
    *   **Data:** Uses `SUSPICIOUS_TLDS` constant.
*   **Function:** `perform_ocr(image_bytes: bytes)` (async)
    *   **Purpose:** Perform OCR on image bytes using Tesseract.
    *   **Inputs:** `image_bytes` (bytes).
    *   **Outputs:** Tuple (string: extracted text or None, string: error message or None).
    *   **Dependencies:** `PIL.Image`, `pytesseract`, `io`, `logging`, `config.config.CONFIG`. Needs Tesseract installed.
    *   **Internal Calls:** None.
    *   **Behavior:** Checks if OCR enabled/dependencies met. Opens image from bytes using `PIL` and `io.BytesIO`. Calls `pytesseract.image_to_string` with languages from config. Handles `UnidentifiedImageError`, `TesseractNotFoundError`, and general exceptions.
    *   **Data:** Processes `image_bytes`. Reads `OCR_ENABLED`, `OCR_LANGUAGES` from `CONFIG`.
*   **Class:** `VirusTotalClient`
    *   **Purpose:** Asynchronous client for interacting with the VirusTotal API v3.
    *   **`__init__(self, api_key: Optional[str], db_manager: DatabaseManager)`**
        *   **Purpose:** Initializes the client with API key and database manager.
        *   **Inputs:** `api_key`, `db_manager`.
        *   **Outputs:** None.
        *   **Dependencies:** `aiohttp`, `logging`, `config.config.CONFIG`. Raises `ImportError` if `aiohttp` missing.
        *   **Internal Calls:** None.
        *   **Behavior:** Stores key/db_manager. Sets up headers, timeout, request delay based on `CONFIG`. Logs status.
        *   **Data:** Reads `VIRUSTOTAL_API_KEY`, `VT_TIMEOUT`, `VT_REQUEST_DELAY_SECONDS`, `USER_AGENT` from `CONFIG`.
    *   **`_request(self, session: aiohttp.ClientSession, endpoint: str, method: str = 'GET', data: Optional[Dict] = None)`** (async, private)
        *   **Purpose:** Internal helper to make the actual HTTP request to VirusTotal.
        *   **Inputs:** `session`, `endpoint`, `method`, `data`.
        *   **Outputs:** Dictionary (VT JSON response or error details).
        *   **Dependencies:** `aiohttp`, `asyncio`, `json`, `logging`.
        *   **Internal Calls:** None.
        *   **Behavior:** Checks API key. Constructs URL. Applies request delay (`asyncio.sleep`). Makes GET or POST request using `session`. Handles 404 on GET specifically. Raises status for other errors. Parses JSON response. Catches `aiohttp` errors (response, timeout, connection, client) and general exceptions, returning structured error dicts.
        *   **Data:** Uses `self.api_key`, `self.headers`, `self.timeout`, `self.request_delay`. Processes `data` for POST.
    *   **`check_indicator(self, session: aiohttp.ClientSession, indicator: str, indicator_type: str)`** (async)
        *   **Purpose:** Checks an indicator (IP, URL, hash) against VT, using cache first. Submits URL if not found.
        *   **Inputs:** `session`, `indicator`, `indicator_type`.
        *   **Outputs:** Dictionary (VT attributes, cache status, or error details).
        *   **Dependencies:** `aiohttp`, `logging`, `re`, `hashlib`, `ipaddress`, `urllib.parse.urlparse`, `src.database_manager.DatabaseManager`.
        *   **Internal Calls:** `self.db_manager.get_cached_result()`, `self._request()`, `self.db_manager.store_result()`.
        *   **Behavior:**
            1.  Checks API key.
            2.  Checks cache via `db_manager.get_cached_result`. Returns if hit.
            3.  Validates indicator format based on `indicator_type` (IP, URL, hash).
            4.  Constructs appropriate VT API endpoint (`/ip_addresses`, `/urls/url_hash`, `/files/hash`).
            5.  Calls `self._request` with GET method.
            6.  If successful GET: extracts attributes, stores in cache via `db_manager.store_result`, returns attributes.
            7.  If URL GET returns 404: calls `self._request` with POST to submit URL. Returns status indicating submission/failure.
            8.  If GET returns other error: returns structured error dict.
        *   **Data:** Processes `indicator`. Interacts with `db_manager`.
        *   **Validation:** Indicator format validation.
*   **Function:** `analyze_authentication_headers(msg: EmailMessage)`
    *   **Purpose:** Parse email headers (`Authentication-Results`, `Received-SPF`, `DKIM-Signature`) to determine SPF, DKIM, DMARC status. Performs DMARC DNS lookup if enabled.
    *   **Inputs:** `msg` (EmailMessage object).
    *   **Outputs:** Dictionary containing structured results for 'spf', 'dkim', 'dmarc', and an 'errors' list.
    *   **Dependencies:** `re`, `logging`, `email.message.EmailMessage`, `dns.resolver`, `dns.exception` (optional).
    *   **Internal Calls:** `decode_email_header`, `extract_domain`.
    *   **Behavior:**
        1.  Initializes results dict. Extracts `From` domain.
        2.  Parses `Authentication-Results` first using regex for spf, dkim, dmarc results, domains, selectors, policy.
        3.  If SPF not found, parses `Received-SPF`.
        4.  If DKIM not found, checks for `DKIM-Signature` existence and extracts d=/s= tags.
        5.  If `dnspython` available and DMARC domain found, performs DNS TXT query for `_dmarc.<domain>`. Parses result for policy ('p=' tag). Handles DNS exceptions (NXDOMAIN, NoAnswer, Timeout).
        6.  Updates DMARC status based on DNS results or prior parsing. Appends errors to list.
    *   **Data:** Reads headers from `msg`.
    *   **Validation:** Checks DMARC domain alignment.
*   **Function:** `check_typosquatting(domain_to_check: str, known_domains: Set[str], threshold: int = 2)`
    *   **Purpose:** Check if a domain name is suspiciously similar (based on Levenshtein distance) to any in a known set.
    *   **Inputs:** `domain_to_check`, `known_domains` (Set of strings), `threshold` (int).
    *   **Outputs:** Dictionary {'similar_to': str, 'distance': int} or `None`.
    *   **Dependencies:** `Levenshtein.distance` (optional), `logging`. Uses `KNOWN_BRAND_DOMAINS`.
    *   **Internal Calls:** None.
    *   **Behavior:** Checks if `levenshtein_distance` is available. Normalizes input domain (lowercase, no www). Compares base part (before first dot) against base parts of known domains using Levenshtein distance. Returns details if distance is > 0 and <= threshold.
    *   **Data:** Uses `KNOWN_BRAND_DOMAINS` constant or passed `known_domains`. Reads `TYPOSQUATTING_THRESHOLD` from `CONFIG`.
*   **Function:** `analyze_headers(msg: EmailMessage, vt_client: VirusTotalClient, session: aiohttp.ClientSession)` (async)
    *   **Purpose:** Comprehensive analysis of email headers.
    *   **Inputs:** `msg`, `vt_client`, `session`.
    *   **Outputs:** Dictionary containing decoded headers, auth results, IP VT analysis, suspicious indicators, From domain details.
    *   **Dependencies:** `logging`, `re`, `ipaddress`, `asyncio`, `aiohttp`.
    *   **Internal Calls:** `decode_email_header`, `analyze_authentication_headers`, `extract_domain`, `vt_client.check_indicator`, `is_suspicious_tld`, `check_typosquatting`.
    *   **Behavior:**
        1.  Decodes standard headers (Subject, From, To, etc.).
        2.  Calls `analyze_authentication_headers`.
        3.  Parses all `Received` headers, extracts public IPv4 addresses using regex and `ipaddress` validation.
        4.  Creates `asyncio` tasks to check unique public IPs via `vt_client.check_indicator`. Gathers results.
        5.  Checks for From/Reply-To domain mismatch.
        6.  Checks for bulk mailer keywords in specific headers.
        7.  Checks for missing standard headers (Date, Message-ID, From).
        8.  Analyzes `From` domain: checks TLD, SPF/DKIM alignment, typosquatting via `check_typosquatting`.
        9.  Aggregates findings into the result dictionary.
    *   **Data:** Reads headers from `msg`. Interacts with `vt_client`. Uses `KNOWN_BRAND_DOMAINS`.
    *   **Validation:** IP address format/type. From/Reply-To mismatch. SPF/DKIM alignment.
*   **Function:** `analyze_body(msg: EmailMessage, vt_client: VirusTotalClient, session: aiohttp.ClientSession)` (async)
    *   **Purpose:** Comprehensive analysis of email body content (text and HTML).
    *   **Inputs:** `msg`, `vt_client`, `session`.
    *   **Outputs:** Dictionary containing text/HTML snippets, links, URL VT analysis, suspicious elements, brand info, link typosquatting results.
    *   **Dependencies:** `logging`, `re`, `asyncio`, `aiohttp`, `urllib.parse.urlparse`.
    *   **Internal Calls:** `part.get_payload`, `part.get_content_type`, `part.get_content_charset`, `decode_email_header` (for filename in part logic), `extract_domain`, `vt_client.check_indicator`, `check_typosquatting`.
    *   **Behavior:**
        1.  Walks through email parts, extracts decoded `text/plain` and `text/html` content (avoiding attachments). Stores snippets.
        2.  Uses regex (`URL_REGEX`, `href` extraction) to find all unique URLs in combined text/HTML. Normalizes URLs.
        3.  If HTML exists: checks for `<input>`, `<form>`, known URL shorteners, hidden text patterns (style checks), `<script>` tags, `<meta refresh>`. Adds findings to `Suspicious_Elements`.
        4.  Creates `asyncio` tasks to check unique URLs via `vt_client.check_indicator`.
        5.  Checks unique link domains for typosquatting via `check_typosquatting`. Adds findings.
        6.  Gathers URL VT results.
        7.  Performs basic brand impersonation check: finds mentions of `KNOWN_BRAND_DOMAINS` in content. Compares mentioned brands to unique link domains. Determines match status (`match`, `mismatch`, etc.) and adds notes.
        8.  Aggregates findings into the result dictionary.
    *   **Data:** Reads body parts from `msg`. Interacts with `vt_client`. Uses `KNOWN_BRAND_DOMAINS`. Reads `TYPOSQUATTING_THRESHOLD` from `CONFIG`.
    *   **Validation:** URL format. Link domain vs. mentioned brand matching.
*   **Function:** `analyze_attachments(msg: EmailMessage, vt_client: VirusTotalClient, session: aiohttp.ClientSession)` (async)
    *   **Purpose:** Analyze email attachments for metadata, hashes, OCR text, and suspicious indicators.
    *   **Inputs:** `msg`, `vt_client`, `session`.
    *   **Outputs:** Dictionary containing attachment data (per file), hash VT analysis, and suspicious indicators list.
    *   **Dependencies:** `logging`, `os`, `asyncio`, `aiohttp`, `config.config.CONFIG`. Optional: `PIL`, `pytesseract`.
    *   **Internal Calls:** `part.get_filename`, `part.get_payload`, `decode_email_header`, `generate_hashes`, `perform_ocr`, `vt_client.check_indicator`.
    *   **Behavior:**
        1.  Walks through email parts, identifying attachments via filename or `Content-Disposition`. Handles duplicate filenames.
        2.  For each attachment: decodes payload, gets size/type, calls `generate_hashes`.
        3.  If OCR enabled and image type matches `OCR_IMAGE_CONTENT_TYPES`, calls `perform_ocr` and stores text/error. Checks OCR text for keywords.
        4.  Checks filename extension against lists of suspicious types (executables, archives, macro-enabled docs). Checks for large PDFs, double extensions. Adds findings to `Suspicious_Indicators`.
        5.  Stores attachment metadata (size, type, hashes, ocr) in `Data` dict.
        6.  Creates `asyncio` tasks to check unique SHA256 hashes via `vt_client.check_indicator`.
        7.  Gathers hash VT results and stores them in `Hash_Analysis`. Adds notes to `Suspicious_Indicators` if VT results are malicious/suspicious.
        8.  Aggregates findings into the result dictionary.
    *   **Data:** Reads attachment parts from `msg`. Interacts with `vt_client`. Uses `OCR_IMAGE_CONTENT_TYPES`. Reads `OCR_ENABLED` from `CONFIG`.
    *   **Validation:** Attachment type/extension checks.

---

**File:** `src/ai_integration.py`

*   **Function:** `build_ai_prompt(analysis_data: Dict[str, Any])`
    *   **Purpose:** Construct the detailed text prompt to send to the AI model, incorporating all collected analysis data.
    *   **Inputs:** `analysis_data` (dictionary containing results from header, body, attachment analyses).
    *   **Outputs:** Dictionary `{'role': 'user', 'content': str}` or `None` if essential data missing.
    *   **Dependencies:** `logging`, `json`. Uses `AI_JSON_OUTPUT_STRUCTURE` constant.
    *   **Internal Calls:** None.
    *   **Behavior:** Checks for required 'Headers' and 'Body' keys in input. Formats data from `analysis_data` (headers, auth, IPs, body snippets, links, brand info, attachments, hashes, OCR) into a structured text prompt. Includes instructions and the expected JSON output format.
    *   **Data:** Reads from `analysis_data`. Uses `AI_JSON_OUTPUT_STRUCTURE`.
    *   **Validation:** Checks for presence of 'Headers' and 'Body' analysis data.
*   **Function:** `analyze_with_ai(analysis_data: Dict[str, Any], session: aiohttp.ClientSession)` (async)
    *   **Purpose:** Send the analysis data to the AI model via API, receive and parse the JSON response.
    *   **Inputs:** `analysis_data`, `session` (aiohttp client session).
    *   **Outputs:** Dictionary containing the AI's parsed JSON response, or an error dictionary.
    *   **Dependencies:** `aiohttp` (optional), `asyncio`, `json`, `logging`, `config.config.CONFIG`.
    *   **Internal Calls:** `build_ai_prompt`.
    *   **Behavior:**
        1.  Checks if `aiohttp` is available.
        2.  Reads AI config (`AI_API_KEY`, `AI_API_URL`, `AI_MODEL`, timeouts, etc.) from `CONFIG`. Checks if key/URL/model are set.
        3.  Calls `build_ai_prompt` to get the message payload. Returns error if prompt fails.
        4.  Constructs HTTP headers (Authorization, Content-Type, etc.) and JSON payload for the API request.
        5.  Makes POST request to `AI_API_URL` using `session.post` with timeout.
        6.  Handles HTTP errors (`response.raise_for_status()`).
        7.  Parses the JSON response from the AI. Extracts content.
        8.  Cleans potential markdown formatting (```json) from the AI's content string.
        9.  Parses the cleaned content string into a Python dictionary (`json.loads`).
        10. Validates if the parsed dictionary contains all fields defined in `AI_JSON_OUTPUT_STRUCTURE`. Returns error if fields missing.
        11. Returns the parsed AI response dictionary on success.
        12. Catches `aiohttp` errors (response, timeout, connection, client), `ValueError` (from prompt building or JSON parsing), and general exceptions, returning structured error dicts.
    *   **Data:** Reads from `analysis_data`. Reads settings from `CONFIG`. Uses `AI_JSON_OUTPUT_STRUCTURE`. Sends data to external AI API.
    *   **Validation:** Checks config, prompt generation, API response status, response format (looks for 'choices', 'content'), JSON parsing, required fields in AI JSON output.

---

**File:** `src/report_generator.py`

*   **Function:** `draw_box(title: str, color: str, width: int)`
    *   **Purpose:** Create a string representing a text box with a title.
    *   **Inputs:** `title`, `color` (from `COLORS`), `width`.
    *   **Outputs:** Formatted string.
    *   **Dependencies:** `colorama` (optional). Uses `COLORS`.
*   **Function:** `wrap_text(text: str, width: int, indent: str, subsequent_indent: Optional[str])`
    *   **Purpose:** Wrap text to a specified width with indentation.
    *   **Inputs:** `text`, `width`, `indent`, `subsequent_indent`.
    *   **Outputs:** Formatted string.
    *   **Dependencies:** `textwrap`.
*   **Function:** `format_key_value(key: str, value: Any, indent: str, key_width: int)`
    *   **Purpose:** Format a key-value pair for aligned console output with color.
    *   **Inputs:** `key`, `value`, `indent`, `key_width`.
    *   **Outputs:** Formatted string.
    *   **Dependencies:** `colorama` (optional). Uses `COLORS`.
*   **Function:** `format_vt_result(result: Optional[Dict[str, Any]])`
    *   **Purpose:** Create a concise, colored summary string from a VirusTotal result dictionary.
    *   **Inputs:** `result` (VT result dictionary or None).
    *   **Outputs:** Formatted string.
    *   **Dependencies:** `colorama` (optional). Uses `COLORS`.
    *   **Behavior:** Handles None input, error key in result. Extracts malicious/suspicious counts, reputation, votes. Assigns color based on counts. Includes '(Cached)' marker if applicable.
*   **Function:** `format_auth_result(auth_type: str, result: Dict[str, Any])`
    *   **Purpose:** Create a colored string summarizing an authentication result (SPF/DKIM/DMARC).
    *   **Inputs:** `auth_type` (str), `result` (dictionary).
    *   **Outputs:** Formatted string.
    *   **Dependencies:** `colorama` (optional). Uses `COLORS`.
    *   **Behavior:** Extracts status, domain, policy, source. Assigns color based on status. Includes domain, selector (DKIM), policy (DMARC), source (if not default).
*   **Function:** `print_information(info: Dict[str, Any])`
    *   **Purpose:** Print the General Information section of the report.
    *   **Inputs:** `info` dictionary.
    *   **Outputs:** Prints to console.
    *   **Dependencies:** `config.config.CONFIG`.
    *   **Internal Calls:** `draw_box`, `format_key_value`.
*   **Function:** `print_hashes(hashes: Optional[Dict[str, str]])`
    *   **Purpose:** Print the File Hashes section.
    *   **Inputs:** `hashes` dictionary or None.
    *   **Outputs:** Prints to console.
    *   **Internal Calls:** `draw_box`, `format_key_value`.
*   **Function:** `print_headers(headers: Optional[Dict[str, Any]], verbose: bool)`
    *   **Purpose:** Print the Header Analysis section.
    *   **Inputs:** `headers` dictionary or None, `verbose` flag.
    *   **Outputs:** Prints to console.
    *   **Dependencies:** `ipaddress`.
    *   **Internal Calls:** `draw_box`, `format_key_value`, `format_auth_result`, `format_vt_result`, `wrap_text`.
*   **Function:** `print_body(body: Optional[Dict[str, Any]], verbose: bool)`
    *   **Purpose:** Print the Body Analysis section.
    *   **Inputs:** `body` dictionary or None, `verbose` flag.
    *   **Outputs:** Prints to console.
    *   **Dependencies:** `re`.
    *   **Internal Calls:** `draw_box`, `wrap_text`, `format_vt_result`, `format_key_value`.
*   **Function:** `print_attachments(attachments: Optional[Dict[str, Any]], verbose: bool)`
    *   **Purpose:** Print the Attachments Analysis section.
    *   **Inputs:** `attachments` dictionary or None, `verbose` flag.
    *   **Outputs:** Prints to console.
    *   **Internal Calls:** `draw_box`, `format_key_value`, `format_vt_result`, `wrap_text`.
*   **Function:** `print_ai_analysis(ai_data: Optional[Dict[str, Any]])`
    *   **Purpose:** Print the AI Analysis Summary section.
    *   **Inputs:** `ai_data` dictionary or None.
    *   **Outputs:** Prints to console.
    *   **Internal Calls:** `draw_box`, `format_key_value`, `wrap_text`.
*   **Function:** `generate_report(results: Dict[str, Any], verbose: bool = False)`
    *   **Purpose:** Orchestrate the printing of the full console report by calling section-specific print functions.
    *   **Inputs:** `results` (full analysis dictionary), `verbose` flag.
    *   **Outputs:** Prints to console.
    *   **Internal Calls:** `print_information`, `print_hashes`, `print_headers`, `print_body`, `print_attachments`, `print_ai_analysis`, `draw_box`.
    *   **Behavior:** Calls print functions in sequence for each section of the `results` dictionary. Handles case where analysis failed early.

---

**File:** `main.py`

*   **Function:** `run_full_email_analysis(file_path: str, use_ai: bool = False)` (async)
    *   **Purpose:** Orchestrates the entire email analysis process from parsing to AI analysis.
    *   **Inputs:** `file_path` (str), `use_ai` (bool).
    *   **Outputs:** Dictionary containing structured analysis results under "Information" and "Analysis" keys, or an "Error" key.
    *   **Dependencies:** `asyncio`, `aiohttp`, `datetime`, `os`, `time`, `logging`, `config.config.CONFIG`, `src.email_parser`, `src.security_analyzer`, `src.ai_integration`, `src.database_manager`.
    *   **Internal Calls:** `DatabaseManager()`, `db_manager.init_db()`, `VirusTotalClient()`, `parse_email()`, `generate_hashes()`, `analyze_headers()`, `analyze_body()`, `analyze_attachments()`, `analyze_with_ai()` (optional), `db_manager.prune_old_cache()`.
    *   **Behavior:**
        1.  Records start time, initializes results dict.
        2.  Checks for `aiohttp`. Initializes `DatabaseManager` and `VirusTotalClient`.
        3.  Creates `aiohttp.ClientSession`.
        4.  Calls `parse_email`.
        5.  Calls `generate_hashes` on raw content.
        6.  Creates `asyncio` tasks for `analyze_headers`, `analyze_body`, `analyze_attachments`.
        7.  Uses `asyncio.gather` to run component analyses concurrently and collects results/exceptions. Stores results or error info.
        8.  If `use_ai` is true and AI is enabled, creates task for `analyze_with_ai`, awaits it, and stores result/error.
        9.  Determines final status ("Success", "Completed with errors", "Failed").
        10. Calculates duration.
        11. Calls `db_manager.prune_old_cache`.
        12. Returns the results dictionary. Handles `EmailAnalysisError` and general exceptions.
    *   **Data:** Reads config from `CONFIG`. Processes email file. Interacts with `db_manager`, `vt_client`, `ai_integration`.
    *   **Logs:** Info/Debug/Warning/Error/Exception throughout the workflow stages.
*   **Function:** `save_results(results: dict, output_path: str)`
    *   **Purpose:** Save the analysis results dictionary to a JSON file.
    *   **Inputs:** `results` (dict), `output_path` (str).
    *   **Outputs:** Boolean (True on success, False on failure).
    *   **Dependencies:** `os`, `json`, `logging`.
    *   **Internal Calls:** None.
    *   **Behavior:** Creates output directory if needed (`os.makedirs`). Opens file for writing. Uses `json.dump` to serialize the dictionary with indentation. Handles `OSError`, `TypeError`, and general exceptions during file writing/serialization. Prints error messages to stderr on failure.
    *   **Data:** Writes `results` dict content to `output_path`.
*   **Function:** `async_main()` (async)
    *   **Purpose:** Handles command-line argument parsing and orchestrates the top-level execution flow.
    *   **Inputs:** Command-line arguments.
    *   **Outputs:** Prints report to console, optionally saves JSON file, exits with status code 0 or 1.
    *   **Dependencies:** `sys`, `argparse`, `logging`, `asyncio`, `pytesseract` (optional, for check), `config.config.CONFIG`.
    *   **Internal Calls:** `ArgumentParser()`, `parser.parse_args()`, `run_full_email_analysis()`, `generate_report()`, `save_results()`, `sys.exit()`.
    *   **Behavior:**
        1.  Parses command-line args (`-f`, `--ai`, `-o`, `-v`).
        2.  Performs initial checks (`aiohttp` presence, Tesseract presence if OCR enabled).
        3.  Prints startup information (file, settings).
        4.  Calls `run_full_email_analysis` and awaits results.
        5.  Calls `generate_report` to print console output.
        6.  If output path provided, calls `save_results`.
        7.  Determines exit code based on errors in results. Prints final status/error.
        8.  Exits using `sys.exit()`.
*   **`if __name__ == "__main__":` block**
    *   **Purpose:** Entry point when script is run directly.
    *   **Dependencies:** `asyncio`, `sys`, `logging`, `aiohttp`.
    *   **Internal Calls:** `asyncio.run(async_main())`.
    *   **Behavior:** Sets up basic logging. Checks for `aiohttp`. Calls `asyncio.run` to execute the `async_main` function. Handles `KeyboardInterrupt` and top-level exceptions gracefully.

---

### 3. Visual Tree

```
main.py (async_main)
│
├── Argument Parsing (-f, --ai, -o, -v)
│
├── Initial Checks (aiohttp, Tesseract if OCR enabled)
│
├── run_full_email_analysis(file_path, use_ai) [async]
│   │
│   ├── Init DatabaseManager
│   │   └── db_manager.init_db() [async]
│   │
│   ├── Init VirusTotalClient
│   │
│   ├── Create aiohttp.ClientSession
│   │
│   ├── parse_email(file_path) -> email_data
│   │   └── (Handles .eml/.msg, checks size/type)
│   │
│   ├── generate_hashes(email_data['raw_content']) -> hashes
│   │
│   ├── Run Concurrently via asyncio.gather:
│   │   ├── Task 1: analyze_headers(msg, vt_client, session) [async] -> headers_result
│   │   │   ├── analyze_authentication_headers(msg)
│   │   │   │   └── (Parses Auth-Results, Received-SPF, DKIM-Sig, DNS DMARC Lookup [async])
│   │   │   ├── Extracts Public IPs from Received Headers
│   │   │   ├── Creates VT IP check tasks -> vt_client.check_indicator(ip) [async] (uses cache)
│   │   │   │   └── db_manager.get_cached_result() [async]
│   │   │   │   └── _request() [async] (to VT API)
│   │   │   │   └── db_manager.store_result() [async]
│   │   │   ├── Gathers VT IP results
│   │   │   └── Checks From/Reply-To mismatch, bulk headers, From domain (TLD, alignment, typosquatting)
│   │   │       └── check_typosquatting()
│   │   │
│   │   ├── Task 2: analyze_body(msg, vt_client, session) [async] -> body_result
│   │   │   ├── Extracts Text/HTML content
│   │   │   ├── Extracts Links (Regex, href)
│   │   │   ├── Analyzes HTML (forms, inputs, shorteners, hidden text, scripts, meta-refresh)
│   │   │   ├── Creates VT URL check tasks -> vt_client.check_indicator(url) [async] (uses cache, may submit URL)
│   │   │   │   └── (Similar flow as IP check)
│   │   │   ├── Checks Link Domains for typosquatting -> check_typosquatting()
│   │   │   ├── Gathers VT URL results
│   │   │   └── Checks Brand Impersonation (mentions vs link domains)
│   │   │
│   │   └── Task 3: analyze_attachments(msg, vt_client, session) [async] -> attachments_result
│   │       ├── Identifies/Extracts Attachments
│   │       ├── generate_hashes(attachment_payload)
│   │       ├── If OCR enabled & image: perform_ocr(attachment_payload) [async]
│   │       ├── Checks for suspicious extensions, size, double extensions
│   │       ├── Creates VT Hash check tasks -> vt_client.check_indicator(hash) [async] (uses cache)
│   │       │   └── (Similar flow as IP check)
│   │       └── Gathers VT Hash results
│   │
│   ├── (Optional) If use_ai: analyze_with_ai(analysis_results, session) [async] -> ai_result
│   │   ├── build_ai_prompt(analysis_results) -> prompt
│   │   └── Makes API call to AI Service (e.g., OpenRouter) [async]
│   │   └── Parses and validates AI JSON response
│   │
│   └── db_manager.prune_old_cache() [async]
│
├── generate_report(results, verbose)
│   │   (Calls various print_* functions which use format_* helpers)
│
├── (Optional) If output path provided: save_results(results, output_path)
│
└── Exit (Code 0 or 1)
```